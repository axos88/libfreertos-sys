/* automatically generated by rust-bindgen */

pub const pdTRUE: u32 = 1;
pub const pdFALSE: u32 = 0;
pub const pdPASS: u32 = 1;
pub const pdFAIL: u32 = 0;
pub const errQUEUE_EMPTY: u32 = 0;
pub const errQUEUE_FULL: u32 = 0;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errNO_TASK_TO_RUN: i32 = -2;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_PREEMPTION: u32 = 1;
pub const configUSE_IDLE_HOOK: u32 = 1;
pub const configUSE_TICK_HOOK: u32 = 1;
pub const configMAX_TASK_NAME_LEN: u32 = 0;
pub const configUSE_TRACE_FACILITY: u32 = 0;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 1;
pub const configUSE_CO_ROUTINES: u32 = 1;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_EVENTS: u32 = 1;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 2;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configQUEUE_REGISTRY_SIZE: u32 = 3;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskCleanUpResources: u32 = 1;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 1;
pub const configMAC_ADDR0: u32 = 0;
pub const configMAC_ADDR1: u32 = 18;
pub const configMAC_ADDR2: u32 = 19;
pub const configMAC_ADDR3: u32 = 16;
pub const configMAC_ADDR4: u32 = 21;
pub const configMAC_ADDR5: u32 = 17;
pub const configIP_ADDR0: u32 = 192;
pub const configIP_ADDR1: u32 = 168;
pub const configIP_ADDR2: u32 = 0;
pub const configIP_ADDR3: u32 = 201;
pub const configNET_MASK0: u32 = 255;
pub const configNET_MASK1: u32 = 255;
pub const configNET_MASK2: u32 = 255;
pub const configNET_MASK3: u32 = 0;
pub const configPRIO_BITS: u32 = 5;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 248;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 40;
pub const configEMAC_INTERRUPT_PRIORITY: u32 = 5;
pub const configUSB_INTERRUPT_PRIORITY: u32 = 6;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 8;
pub const portBYTE_ALIGNMENT_MASK: u32 = 7;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 0;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 0;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 1;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 1;
pub const tskKERNEL_VERSION_NUMBER: &'static [u8; 7usize] = b"V6.1.0\0";
pub const taskSCHEDULER_NOT_STARTED: u32 = 0;
pub const taskSCHEDULER_RUNNING: u32 = 1;
pub const taskSCHEDULER_SUSPENDED: u32 = 2;
pub const queueSEND_TO_BACK: u32 = 0;
pub const queueSEND_TO_FRONT: u32 = 1;
pub type wchar_t = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: c_types::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type pdTASK_CODE = ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>;
extern "C" {
    pub static mut SystemCoreClock: c_types::c_int;
}
pub type portTickType = c_types::c_ulong;
extern "C" {
    pub fn vPortYieldFromISR();
}
extern "C" {
    pub fn vPortEnterCritical();
}
extern "C" {
    pub fn vPortExitCritical();
}
extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut c_types::c_ulong,
        pxCode: pdTASK_CODE,
        pvParameters: *mut c_types::c_void,
    ) -> *mut c_types::c_ulong;
}
extern "C" {
    pub fn pvPortMalloc(xSize: usize) -> *mut c_types::c_void;
}
extern "C" {
    pub fn vPortFree(pv: *mut c_types::c_void);
}
extern "C" {
    pub fn vPortInitialiseBlocks();
}
extern "C" {
    pub fn xPortGetFreeHeapSize() -> usize;
}
extern "C" {
    pub fn xPortStartScheduler() -> c_types::c_long;
}
extern "C" {
    pub fn vPortEndScheduler();
}
pub type pdTASK_HOOK_CODE =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void) -> c_types::c_long>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    pub xItemValue: portTickType,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut c_types::c_void,
    pub pvContainer: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_xLIST_ITEM() {
    assert_eq!(
        ::core::mem::size_of::<xLIST_ITEM>(),
        20usize,
        concat!("Size of: ", stringify!(xLIST_ITEM))
    );
    assert_eq!(
        ::core::mem::align_of::<xLIST_ITEM>(),
        4usize,
        concat!("Alignment of ", stringify!(xLIST_ITEM))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xLIST_ITEM>())).xItemValue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xLIST_ITEM),
            "::",
            stringify!(xItemValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xLIST_ITEM>())).pxNext as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xLIST_ITEM),
            "::",
            stringify!(pxNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xLIST_ITEM>())).pxPrevious as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xLIST_ITEM),
            "::",
            stringify!(pxPrevious)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xLIST_ITEM>())).pvOwner as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xLIST_ITEM),
            "::",
            stringify!(pvOwner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xLIST_ITEM>())).pvContainer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xLIST_ITEM),
            "::",
            stringify!(pvContainer)
        )
    );
}
pub type xListItem = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: portTickType,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
#[test]
fn bindgen_test_layout_xMINI_LIST_ITEM() {
    assert_eq!(
        ::core::mem::size_of::<xMINI_LIST_ITEM>(),
        12usize,
        concat!("Size of: ", stringify!(xMINI_LIST_ITEM))
    );
    assert_eq!(
        ::core::mem::align_of::<xMINI_LIST_ITEM>(),
        4usize,
        concat!("Alignment of ", stringify!(xMINI_LIST_ITEM))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xMINI_LIST_ITEM>())).xItemValue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xMINI_LIST_ITEM),
            "::",
            stringify!(xItemValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xMINI_LIST_ITEM>())).pxNext as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xMINI_LIST_ITEM),
            "::",
            stringify!(pxNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xMINI_LIST_ITEM>())).pxPrevious as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xMINI_LIST_ITEM),
            "::",
            stringify!(pxPrevious)
        )
    );
}
pub type xMiniListItem = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: c_types::c_ulong,
    pub pxIndex: *mut xListItem,
    pub xListEnd: xMiniListItem,
}
#[test]
fn bindgen_test_layout_xLIST() {
    assert_eq!(
        ::core::mem::size_of::<xLIST>(),
        20usize,
        concat!("Size of: ", stringify!(xLIST))
    );
    assert_eq!(
        ::core::mem::align_of::<xLIST>(),
        4usize,
        concat!("Alignment of ", stringify!(xLIST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xLIST>())).uxNumberOfItems as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xLIST),
            "::",
            stringify!(uxNumberOfItems)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xLIST>())).pxIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xLIST),
            "::",
            stringify!(pxIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xLIST>())).xListEnd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xLIST),
            "::",
            stringify!(xListEnd)
        )
    );
}
pub type xList = xLIST;
extern "C" {
    pub fn vListInitialise(pxList: *mut xList);
}
extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut xListItem);
}
extern "C" {
    pub fn vListInsert(pxList: *mut xList, pxNewListItem: *mut xListItem);
}
extern "C" {
    pub fn vListInsertEnd(pxList: *mut xList, pxNewListItem: *mut xListItem);
}
extern "C" {
    pub fn vListRemove(pxItemToRemove: *mut xListItem);
}
#[doc = " task. h"]
#[doc = ""]
#[doc = " Type by which tasks are referenced.  For example, a call to xTaskCreate"]
#[doc = " returns (via a pointer parameter) an xTaskHandle variable that can then"]
#[doc = " be used as a parameter to vTaskDelete to delete the task."]
#[doc = ""]
#[doc = " \\page xTaskHandle xTaskHandle"]
#[doc = " \\ingroup Tasks"]
pub type xTaskHandle = *mut c_types::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: c_types::c_long,
    pub xTimeOnEntering: portTickType,
}
#[test]
fn bindgen_test_layout_xTIME_OUT() {
    assert_eq!(
        ::core::mem::size_of::<xTIME_OUT>(),
        8usize,
        concat!("Size of: ", stringify!(xTIME_OUT))
    );
    assert_eq!(
        ::core::mem::align_of::<xTIME_OUT>(),
        4usize,
        concat!("Alignment of ", stringify!(xTIME_OUT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xTIME_OUT>())).xOverflowCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xTIME_OUT),
            "::",
            stringify!(xOverflowCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xTIME_OUT>())).xTimeOnEntering as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xTIME_OUT),
            "::",
            stringify!(xTimeOnEntering)
        )
    );
}
pub type xTimeOutType = xTIME_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut c_types::c_void,
    pub ulLengthInBytes: c_types::c_ulong,
    pub ulParameters: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_xMEMORY_REGION() {
    assert_eq!(
        ::core::mem::size_of::<xMEMORY_REGION>(),
        12usize,
        concat!("Size of: ", stringify!(xMEMORY_REGION))
    );
    assert_eq!(
        ::core::mem::align_of::<xMEMORY_REGION>(),
        4usize,
        concat!("Alignment of ", stringify!(xMEMORY_REGION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xMEMORY_REGION>())).pvBaseAddress as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xMEMORY_REGION),
            "::",
            stringify!(pvBaseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xMEMORY_REGION>())).ulLengthInBytes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xMEMORY_REGION),
            "::",
            stringify!(ulLengthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xMEMORY_REGION>())).ulParameters as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xMEMORY_REGION),
            "::",
            stringify!(ulParameters)
        )
    );
}
pub type xMemoryRegion = xMEMORY_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMTERS {
    pub pvTaskCode: pdTASK_CODE,
    pub pcName: *const c_types::c_schar,
    pub usStackDepth: c_types::c_ushort,
    pub pvParameters: *mut c_types::c_void,
    pub uxPriority: c_types::c_ulong,
    pub puxStackBuffer: *mut c_types::c_ulong,
    pub xRegions: [xMemoryRegion; 1usize],
}
#[test]
fn bindgen_test_layout_xTASK_PARAMTERS() {
    assert_eq!(
        ::core::mem::size_of::<xTASK_PARAMTERS>(),
        36usize,
        concat!("Size of: ", stringify!(xTASK_PARAMTERS))
    );
    assert_eq!(
        ::core::mem::align_of::<xTASK_PARAMTERS>(),
        4usize,
        concat!("Alignment of ", stringify!(xTASK_PARAMTERS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xTASK_PARAMTERS>())).pvTaskCode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xTASK_PARAMTERS),
            "::",
            stringify!(pvTaskCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xTASK_PARAMTERS>())).pcName as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xTASK_PARAMTERS),
            "::",
            stringify!(pcName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xTASK_PARAMTERS>())).usStackDepth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xTASK_PARAMTERS),
            "::",
            stringify!(usStackDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xTASK_PARAMTERS>())).pvParameters as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xTASK_PARAMTERS),
            "::",
            stringify!(pvParameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xTASK_PARAMTERS>())).uxPriority as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xTASK_PARAMTERS),
            "::",
            stringify!(uxPriority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xTASK_PARAMTERS>())).puxStackBuffer as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xTASK_PARAMTERS),
            "::",
            stringify!(puxStackBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xTASK_PARAMTERS>())).xRegions as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xTASK_PARAMTERS),
            "::",
            stringify!(xRegions)
        )
    );
}
pub type xTaskParameters = xTASK_PARAMTERS;
extern "C" {
    #[doc = " task. h"]
    #[doc = "<pre>"]
    #[doc = "void vTaskAllocateMPURegions( xTaskHandle xTask, const xMemoryRegion * const pxRegions );</pre>"]
    #[doc = ""]
    #[doc = " Memory regions are assigned to a restricted task when the task is created by"]
    #[doc = " a call to xTaskCreateRestricted().  These regions can be redefined using"]
    #[doc = " vTaskAllocateMPURegions()."]
    #[doc = ""]
    #[doc = " @param xTask The handle of the task being updated."]
    #[doc = ""]
    #[doc = " @param xRegions A pointer to an xMemoryRegion structure that contains the"]
    #[doc = " new memory region definitions."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "static const xMemoryRegion xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] ="]
    #[doc = "{"]
    #[doc = "{ ucOneKByte,\t\t1024,\t\tportMPU_REGION_READ_WRITE },"]
    #[doc = "{ 0,\t\t\t\t0,\t\t\t0 },"]
    #[doc = "{ 0,\t\t\t\t0,\t\t\t0 }"]
    #[doc = "};"]
    #[doc = ""]
    #[doc = "void vATask( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "vTaskAllocateMPURegions( NULL, xAltRegions );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xTaskCreateRestricted xTaskCreateRestricted"]
    #[doc = " \\ingroup Tasks"]
    pub fn vTaskAllocateMPURegions(xTask: xTaskHandle, pxRegions: *const xMemoryRegion);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskDelete( xTaskHandle pxTask );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelete must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Remove a task from the RTOS real time kernels management.  The task being"]
    #[doc = " deleted will be removed from all ready, blocked, suspended and event lists."]
    #[doc = ""]
    #[doc = " NOTE:  The idle task is responsible for freeing the kernel allocated"]
    #[doc = " memory from tasks that have been deleted.  It is therefore important that"]
    #[doc = " the idle task is not starved of microcontroller processing time if your"]
    #[doc = " application makes any calls to vTaskDelete ().  Memory allocated by the"]
    #[doc = " task code is not automatically freed, and should be freed before the task"]
    #[doc = " is deleted."]
    #[doc = ""]
    #[doc = " See the demo application file death.c for sample code that utilises"]
    #[doc = " vTaskDelete ()."]
    #[doc = ""]
    #[doc = " @param pxTask The handle of the task to be deleted.  Passing NULL will"]
    #[doc = " cause the calling task to be deleted."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vOtherFunction( void )"]
    #[doc = "{"]
    #[doc = "xTaskHandle xHandle;"]
    #[doc = ""]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "vTaskDelete( xHandle );"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskDelete vTaskDelete"]
    #[doc = " \\ingroup Tasks"]
    pub fn vTaskDelete(pxTask: xTaskHandle);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskDelay( portTickType xTicksToDelay );</pre>"]
    #[doc = ""]
    #[doc = " Delay a task for a given number of ticks.  The actual time that the"]
    #[doc = " task remains blocked depends on the tick rate.  The constant"]
    #[doc = " portTICK_RATE_MS can be used to calculate real time from the tick"]
    #[doc = " rate - with the resolution of one tick period."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelay must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " vTaskDelay() specifies a time at which the task wishes to unblock relative to"]
    #[doc = " the time at which vTaskDelay() is called.  For example, specifying a block"]
    #[doc = " period of 100 ticks will cause the task to unblock 100 ticks after"]
    #[doc = " vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method"]
    #[doc = " of controlling the frequency of a cyclical task as the path taken through the"]
    #[doc = " code, as well as other task and interrupt activity, will effect the frequency"]
    #[doc = " at which vTaskDelay() gets called and therefore the time at which the task"]
    #[doc = " next executes.  See vTaskDelayUntil() for an alternative API function designed"]
    #[doc = " to facilitate fixed frequency execution.  It does this by specifying an"]
    #[doc = " absolute time (rather than a relative time) at which the calling task should"]
    #[doc = " unblock."]
    #[doc = ""]
    #[doc = " @param xTicksToDelay The amount of time, in tick periods, that"]
    #[doc = " the calling task should block."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = ""]
    #[doc = "void vTaskFunction( void * pvParameters )"]
    #[doc = "{"]
    #[doc = "void vTaskFunction( void * pvParameters )"]
    #[doc = "{"]
    #[doc = "const portTickType xDelay = 500 / portTICK_RATE_MS;"]
    #[doc = ""]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = "vToggleLED();"]
    #[doc = "vTaskDelay( xDelay );"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = " \\defgroup vTaskDelay vTaskDelay"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskDelay(xTicksToDelay: portTickType);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskDelayUntil( portTickType *pxPreviousWakeTime, portTickType xTimeIncrement );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Delay a task until a specified time.  This function can be used by cyclical"]
    #[doc = " tasks to ensure a constant execution frequency."]
    #[doc = ""]
    #[doc = " This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will"]
    #[doc = " cause a task to block for the specified number of ticks from the time vTaskDelay () is"]
    #[doc = " called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed"]
    #[doc = " execution frequency as the time between a task starting to execute and that task"]
    #[doc = " calling vTaskDelay () may not be fixed [the task may take a different path though the"]
    #[doc = " code between calls, or may get interrupted or preempted a different number of times"]
    #[doc = " each time it executes]."]
    #[doc = ""]
    #[doc = " Whereas vTaskDelay () specifies a wake time relative to the time at which the function"]
    #[doc = " is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to"]
    #[doc = " unblock."]
    #[doc = ""]
    #[doc = " The constant portTICK_RATE_MS can be used to calculate real time from the tick"]
    #[doc = " rate - with the resolution of one tick period."]
    #[doc = ""]
    #[doc = " @param pxPreviousWakeTime Pointer to a variable that holds the time at which the"]
    #[doc = " task was last unblocked.  The variable must be initialised with the current time"]
    #[doc = " prior to its first use (see the example below).  Following this the variable is"]
    #[doc = " automatically updated within vTaskDelayUntil ()."]
    #[doc = ""]
    #[doc = " @param xTimeIncrement The cycle time period.  The task will be unblocked at"]
    #[doc = " time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the"]
    #[doc = " same xTimeIncrement parameter value will cause the task to execute with"]
    #[doc = " a fixed interface period."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vTaskFunction( void * pvParameters )"]
    #[doc = "{"]
    #[doc = "portTickType xLastWakeTime;"]
    #[doc = "const portTickType xFrequency = 10;"]
    #[doc = ""]
    #[doc = "xLastWakeTime = xTaskGetTickCount ();"]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = "vTaskDelayUntil( &xLastWakeTime, xFrequency );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskDelayUntil vTaskDelayUntil"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskDelayUntil(pxPreviousWakeTime: *mut portTickType, xTimeIncrement: portTickType);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_xTaskPriorityGet must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Obtain the priority of any task."]
    #[doc = ""]
    #[doc = " @param pxTask Handle of the task to be queried.  Passing a NULL"]
    #[doc = " handle results in the priority of the calling task being returned."]
    #[doc = ""]
    #[doc = " @return The priority of pxTask."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "xTaskHandle xHandle;"]
    #[doc = ""]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup uxTaskPriorityGet uxTaskPriorityGet"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn uxTaskPriorityGet(pxTask: xTaskHandle) -> c_types::c_ulong;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Set the priority of any task."]
    #[doc = ""]
    #[doc = " A context switch will occur before the function returns if the priority"]
    #[doc = " being set is higher than the currently executing task."]
    #[doc = ""]
    #[doc = " @param pxTask Handle to the task for which the priority is being set."]
    #[doc = " Passing a NULL handle results in the priority of the calling task being set."]
    #[doc = ""]
    #[doc = " @param uxNewPriority The priority to which the task will be set."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "xTaskHandle xHandle;"]
    #[doc = ""]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskPrioritySet vTaskPrioritySet"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskPrioritySet(pxTask: xTaskHandle, uxNewPriority: c_types::c_ulong);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskSuspend( xTaskHandle pxTaskToSuspend );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Suspend any task.  When suspended a task will never get any microcontroller"]
    #[doc = " processing time, no matter what its priority."]
    #[doc = ""]
    #[doc = " Calls to vTaskSuspend are not accumulative -"]
    #[doc = " i.e. calling vTaskSuspend () twice on the same task still only requires one"]
    #[doc = " call to vTaskResume () to ready the suspended task."]
    #[doc = ""]
    #[doc = " @param pxTaskToSuspend Handle to the task being suspended.  Passing a NULL"]
    #[doc = " handle will cause the calling task to be suspended."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "xTaskHandle xHandle;"]
    #[doc = ""]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskSuspend( xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskSuspend( NULL );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskSuspend vTaskSuspend"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskSuspend(pxTaskToSuspend: xTaskHandle);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskResume( xTaskHandle pxTaskToResume );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Resumes a suspended task."]
    #[doc = ""]
    #[doc = " A task that has been suspended by one of more calls to vTaskSuspend ()"]
    #[doc = " will be made available for running again by a single call to"]
    #[doc = " vTaskResume ()."]
    #[doc = ""]
    #[doc = " @param pxTaskToResume Handle to the task being readied."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "xTaskHandle xHandle;"]
    #[doc = ""]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskSuspend( xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskResume( xHandle );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskResume vTaskResume"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskResume(pxTaskToResume: xTaskHandle);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void xTaskResumeFromISR( xTaskHandle pxTaskToResume );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be"]
    #[doc = " available.  See the configuration section for more information."]
    #[doc = ""]
    #[doc = " An implementation of vTaskResume() that can be called from within an ISR."]
    #[doc = ""]
    #[doc = " A task that has been suspended by one of more calls to vTaskSuspend ()"]
    #[doc = " will be made available for running again by a single call to"]
    #[doc = " xTaskResumeFromISR ()."]
    #[doc = ""]
    #[doc = " @param pxTaskToResume Handle to the task being readied."]
    #[doc = ""]
    #[doc = " \\defgroup vTaskResumeFromISR vTaskResumeFromISR"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn xTaskResumeFromISR(pxTaskToResume: xTaskHandle) -> c_types::c_long;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskStartScheduler( void );</pre>"]
    #[doc = ""]
    #[doc = " Starts the real time kernel tick processing.  After calling the kernel"]
    #[doc = " has control over which tasks are executed and when.  This function"]
    #[doc = " does not return until an executing task calls vTaskEndScheduler ()."]
    #[doc = ""]
    #[doc = " At least one task should be created via a call to xTaskCreate ()"]
    #[doc = " before calling vTaskStartScheduler ().  The idle task is created"]
    #[doc = " automatically when the first application task is created."]
    #[doc = ""]
    #[doc = " See the demo application file main.c for an example of creating"]
    #[doc = " tasks and starting the kernel."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
    #[doc = ""]
    #[doc = "vTaskStartScheduler ();"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = " \\defgroup vTaskStartScheduler vTaskStartScheduler"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskStartScheduler();
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskEndScheduler( void );</pre>"]
    #[doc = ""]
    #[doc = " Stops the real time kernel tick.  All created tasks will be automatically"]
    #[doc = " deleted and multitasking (either preemptive or cooperative) will"]
    #[doc = " stop.  Execution then resumes from the point where vTaskStartScheduler ()"]
    #[doc = " was called, as if vTaskStartScheduler () had just returned."]
    #[doc = ""]
    #[doc = " See the demo application file main. c in the demo/PC directory for an"]
    #[doc = " example that uses vTaskEndScheduler ()."]
    #[doc = ""]
    #[doc = " vTaskEndScheduler () requires an exit function to be defined within the"]
    #[doc = " portable layer (see vPortEndScheduler () in port. c for the PC port).  This"]
    #[doc = " performs hardware specific operations such as stopping the kernel tick."]
    #[doc = ""]
    #[doc = " vTaskEndScheduler () will cause all of the resources allocated by the"]
    #[doc = " kernel to be freed - but will not free resources allocated by application"]
    #[doc = " tasks."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vTaskCode( void * pvParameters )"]
    #[doc = "{"]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = ""]
    #[doc = "vTaskEndScheduler ();"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
    #[doc = ""]
    #[doc = "vTaskStartScheduler ();"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = " \\defgroup vTaskEndScheduler vTaskEndScheduler"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskEndScheduler();
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskSuspendAll( void );</pre>"]
    #[doc = ""]
    #[doc = " Suspends all real time kernel activity while keeping interrupts (including the"]
    #[doc = " kernel tick) enabled."]
    #[doc = ""]
    #[doc = " After calling vTaskSuspendAll () the calling task will continue to execute"]
    #[doc = " without risk of being swapped out until a call to xTaskResumeAll () has been"]
    #[doc = " made."]
    #[doc = ""]
    #[doc = " API functions that have the potential to cause a context switch (for example,"]
    #[doc = " vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler"]
    #[doc = " is suspended."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vTask1( void * pvParameters )"]
    #[doc = "{"]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskSuspendAll ();"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "xTaskResumeAll ();"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskSuspendAll vTaskSuspendAll"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskSuspendAll();
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>char xTaskResumeAll( void );</pre>"]
    #[doc = ""]
    #[doc = " Resumes real time kernel activity following a call to vTaskSuspendAll ()."]
    #[doc = " After a call to vTaskSuspendAll () the kernel will take control of which"]
    #[doc = " task is executing at any time."]
    #[doc = ""]
    #[doc = " @return If resuming the scheduler caused a context switch then pdTRUE is"]
    #[doc = "\t\t  returned, otherwise pdFALSE is returned."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vTask1( void * pvParameters )"]
    #[doc = "{"]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskSuspendAll ();"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "if( !xTaskResumeAll () )"]
    #[doc = "{"]
    #[doc = "taskYIELD ();"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xTaskResumeAll xTaskResumeAll"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn xTaskResumeAll() -> c_types::c_long;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask );</pre>"]
    #[doc = ""]
    #[doc = " Utility task that simply returns pdTRUE if the task referenced by xTask is"]
    #[doc = " currently in the Suspended state, or pdFALSE if the task referenced by xTask"]
    #[doc = " is in any other state."]
    #[doc = ""]
    pub fn xTaskIsTaskSuspended(xTask: xTaskHandle) -> c_types::c_long;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>portTickType xTaskGetTickCount( void );</PRE>"]
    #[doc = ""]
    #[doc = " @return The count of ticks since vTaskStartScheduler was called."]
    #[doc = ""]
    #[doc = " \\page xTaskGetTickCount xTaskGetTickCount"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetTickCount() -> portTickType;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>portTickType xTaskGetTickCountFromISR( void );</PRE>"]
    #[doc = ""]
    #[doc = " @return The count of ticks since vTaskStartScheduler was called."]
    #[doc = ""]
    #[doc = " This is a version of xTaskGetTickCount() that is safe to be called from an"]
    #[doc = " ISR - provided that portTickType is the natural word size of the"]
    #[doc = " microcontroller being used or interrupt nesting is either not supported or"]
    #[doc = " not being used."]
    #[doc = ""]
    #[doc = " \\page xTaskGetTickCount xTaskGetTickCount"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetTickCountFromISR() -> portTickType;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>unsigned short uxTaskGetNumberOfTasks( void );</PRE>"]
    #[doc = ""]
    #[doc = " @return The number of tasks that the real time kernel is currently managing."]
    #[doc = " This includes all ready, blocked and suspended tasks.  A task that"]
    #[doc = " has been deleted but not yet freed by the idle task will also be"]
    #[doc = " included in the count."]
    #[doc = ""]
    #[doc = " \\page uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn uxTaskGetNumberOfTasks() -> c_types::c_ulong;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>void vTaskList( char *pcWriteBuffer );</PRE>"]
    #[doc = ""]
    #[doc = " configUSE_TRACE_FACILITY must be defined as 1 for this function to be"]
    #[doc = " available.  See the configuration section for more information."]
    #[doc = ""]
    #[doc = " NOTE: This function will disable interrupts for its duration.  It is"]
    #[doc = " not intended for normal application runtime use but as a debug aid."]
    #[doc = ""]
    #[doc = " Lists all the current tasks, along with their current state and stack"]
    #[doc = " usage high water mark."]
    #[doc = ""]
    #[doc = " Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or"]
    #[doc = " suspended ('S')."]
    #[doc = ""]
    #[doc = " @param pcWriteBuffer A buffer into which the above mentioned details"]
    #[doc = " will be written, in ascii form.  This buffer is assumed to be large"]
    #[doc = " enough to contain the generated report.  Approximately 40 bytes per"]
    #[doc = " task should be sufficient."]
    #[doc = ""]
    #[doc = " \\page vTaskList vTaskList"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn vTaskList(pcWriteBuffer: *mut c_types::c_schar);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>"]
    #[doc = ""]
    #[doc = " configGENERATE_RUN_TIME_STATS must be defined as 1 for this function"]
    #[doc = " to be available.  The application must also then provide definitions"]
    #[doc = " for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and"]
    #[doc = " portGET_RUN_TIME_COUNTER_VALUE to configure a peripheral timer/counter"]
    #[doc = " and return the timers current count value respectively.  The counter"]
    #[doc = " should be at least 10 times the frequency of the tick count."]
    #[doc = ""]
    #[doc = " NOTE: This function will disable interrupts for its duration.  It is"]
    #[doc = " not intended for normal application runtime use but as a debug aid."]
    #[doc = ""]
    #[doc = " Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total"]
    #[doc = " accumulated execution time being stored for each task.  The resolution"]
    #[doc = " of the accumulated time value depends on the frequency of the timer"]
    #[doc = " configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro."]
    #[doc = " Calling vTaskGetRunTimeStats() writes the total execution time of each"]
    #[doc = " task into a buffer, both as an absolute count value and as a percentage"]
    #[doc = " of the total system execution time."]
    #[doc = ""]
    #[doc = " @param pcWriteBuffer A buffer into which the execution times will be"]
    #[doc = " written, in ascii form.  This buffer is assumed to be large enough to"]
    #[doc = " contain the generated report.  Approximately 40 bytes per task should"]
    #[doc = " be sufficient."]
    #[doc = ""]
    #[doc = " \\page vTaskGetRunTimeStats vTaskGetRunTimeStats"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut c_types::c_schar);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>void vTaskStartTrace( char * pcBuffer, unsigned portBASE_TYPE uxBufferSize );</PRE>"]
    #[doc = ""]
    #[doc = " Starts a real time kernel activity trace.  The trace logs the identity of"]
    #[doc = " which task is running when."]
    #[doc = ""]
    #[doc = " The trace file is stored in binary format.  A separate DOS utility called"]
    #[doc = " convtrce.exe is used to convert this into a tab delimited text file which"]
    #[doc = " can be viewed and plotted in a spread sheet."]
    #[doc = ""]
    #[doc = " @param pcBuffer The buffer into which the trace will be written."]
    #[doc = ""]
    #[doc = " @param ulBufferSize The size of pcBuffer in bytes.  The trace will continue"]
    #[doc = " until either the buffer in full, or ulTaskEndTrace () is called."]
    #[doc = ""]
    #[doc = " \\page vTaskStartTrace vTaskStartTrace"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn vTaskStartTrace(pcBuffer: *mut c_types::c_schar, ulBufferSize: c_types::c_ulong);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>unsigned long ulTaskEndTrace( void );</PRE>"]
    #[doc = ""]
    #[doc = " Stops a kernel activity trace.  See vTaskStartTrace ()."]
    #[doc = ""]
    #[doc = " @return The number of bytes that have been written into the trace buffer."]
    #[doc = ""]
    #[doc = " \\page usTaskEndTrace usTaskEndTrace"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn ulTaskEndTrace() -> c_types::c_ulong;
}
extern "C" {
    #[doc = " task.h"]
    #[doc = " <PRE>unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask );</PRE>"]
    #[doc = ""]
    #[doc = " INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for"]
    #[doc = " this function to be available."]
    #[doc = ""]
    #[doc = " Returns the high water mark of the stack associated with xTask.  That is,"]
    #[doc = " the minimum free stack space there has been (in bytes) since the task"]
    #[doc = " started.  The smaller the returned number the closer the task has come"]
    #[doc = " to overflowing its stack."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task associated with the stack to be checked."]
    #[doc = " Set xTask to NULL to check the stack of the calling task."]
    #[doc = ""]
    #[doc = " @return The smallest amount of free stack space there has been (in bytes)"]
    #[doc = " since the task referenced by xTask was created."]
    pub fn uxTaskGetStackHighWaterMark(xTask: xTaskHandle) -> c_types::c_ulong;
}
extern "C" {
    #[doc = " task.h"]
    #[doc = " <pre>void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction );</pre>"]
    #[doc = ""]
    #[doc = " Sets pxHookFunction to be the task hook function used by the task xTask."]
    #[doc = " Passing xTask as NULL has the effect of setting the calling tasks hook"]
    #[doc = " function."]
    pub fn vTaskSetApplicationTaskTag(xTask: xTaskHandle, pxHookFunction: pdTASK_HOOK_CODE);
}
extern "C" {
    #[doc = " task.h"]
    #[doc = " <pre>void xTaskGetApplicationTaskTag( xTaskHandle xTask );</pre>"]
    #[doc = ""]
    #[doc = " Returns the pxHookFunction value assigned to the task xTask."]
    pub fn xTaskGetApplicationTaskTag(xTask: xTaskHandle) -> pdTASK_HOOK_CODE;
}
extern "C" {
    #[doc = " task.h"]
    #[doc = " <pre>portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction );</pre>"]
    #[doc = ""]
    #[doc = " Calls the hook function associated with xTask.  Passing xTask as NULL has"]
    #[doc = " the effect of calling the Running tasks (the calling task) hook function."]
    #[doc = ""]
    #[doc = " pvParameter is passed to the hook function for the task to interpret as it"]
    #[doc = " wants."]
    pub fn xTaskCallApplicationTaskHook(
        xTask: xTaskHandle,
        pvParameter: *mut c_types::c_void,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn vTaskIncrementTick();
}
extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *const xList, xTicksToWait: portTickType);
}
extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const xList) -> c_types::c_long;
}
extern "C" {
    pub fn vTaskCleanUpResources();
}
extern "C" {
    pub fn vTaskSwitchContext();
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> xTaskHandle;
}
extern "C" {
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut xTimeOutType);
}
extern "C" {
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut xTimeOutType,
        pxTicksToWait: *mut portTickType,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn vTaskMissedYield();
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> c_types::c_long;
}
extern "C" {
    pub fn vTaskPriorityInherit(pxMutexHolder: *mut xTaskHandle);
}
extern "C" {
    pub fn vTaskPriorityDisinherit(pxMutexHolder: *mut xTaskHandle);
}
extern "C" {
    pub fn xTaskGenericCreate(
        pvTaskCode: pdTASK_CODE,
        pcName: *const c_types::c_char,
        usStackDepth: c_types::c_ushort,
        pvParameters: *mut c_types::c_void,
        uxPriority: c_types::c_ulong,
        pxCreatedTask: *mut xTaskHandle,
        puxStackBuffer: *mut c_types::c_ulong,
        xRegions: *const xMemoryRegion,
    ) -> c_types::c_long;
}
pub type xQueueHandle = *mut c_types::c_void;
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>"]
    #[doc = "xQueueHandle xQueueCreate("]
    #[doc = "unsigned portBASE_TYPE uxQueueLength,"]
    #[doc = "unsigned portBASE_TYPE uxItemSize"]
    #[doc = ");"]
    #[doc = " </pre>"]
    #[doc = ""]
    #[doc = " Creates a new queue instance.  This allocates the storage required by the"]
    #[doc = " new queue and returns a handle for the queue."]
    #[doc = ""]
    #[doc = " @param uxQueueLength The maximum number of items that the queue can contain."]
    #[doc = ""]
    #[doc = " @param uxItemSize The number of bytes each item in the queue will require."]
    #[doc = " Items are queued by copy, not by reference, so this is the number of bytes"]
    #[doc = " that will be copied for each posted item.  Each item on the queue must be"]
    #[doc = " the same size."]
    #[doc = ""]
    #[doc = " @return If the queue is successfully create then a handle to the newly"]
    #[doc = " created queue is returned.  If the queue cannot be created then 0 is"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "struct AMessage"]
    #[doc = "{"]
    #[doc = "char ucMessageID;"]
    #[doc = "char ucData[ 20 ];"]
    #[doc = "};"]
    #[doc = ""]
    #[doc = "void vATask( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "xQueueHandle xQueue1, xQueue2;"]
    #[doc = ""]
    #[doc = "xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );"]
    #[doc = "if( xQueue1 == 0 )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = "if( xQueue2 == 0 )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xQueueCreate xQueueCreate"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueCreate(
        uxQueueLength: c_types::c_ulong,
        uxItemSize: c_types::c_ulong,
    ) -> xQueueHandle;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>"]
    #[doc = "portBASE_TYPE xQueueGenericSend("]
    #[doc = "xQueueHandle xQueue,"]
    #[doc = "const void * pvItemToQueue,"]
    #[doc = "portTickType xTicksToWait"]
    #[doc = "portBASE_TYPE xCopyPosition"]
    #[doc = ");"]
    #[doc = " </pre>"]
    #[doc = ""]
    #[doc = " It is preferred that the macros xQueueSend(), xQueueSendToFront() and"]
    #[doc = " xQueueSendToBack() are used in place of calling this function directly."]
    #[doc = ""]
    #[doc = " Post an item on a queue.  The item is queued by copy, not by reference."]
    #[doc = " This function must not be called from an interrupt service routine."]
    #[doc = " See xQueueSendFromISR () for an alternative which may be used in an ISR."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue on which the item is to be posted."]
    #[doc = ""]
    #[doc = " @param pvItemToQueue A pointer to the item that is to be placed on the"]
    #[doc = " queue.  The size of the items the queue will hold was defined when the"]
    #[doc = " queue was created, so this many bytes will be copied from pvItemToQueue"]
    #[doc = " into the queue storage area."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time the task should block"]
    #[doc = " waiting for space to become available on the queue, should it already"]
    #[doc = " be full.  The call will return immediately if this is set to 0 and the"]
    #[doc = " queue is full.  The time is defined in tick periods so the constant"]
    #[doc = " portTICK_RATE_MS should be used to convert to real time if this is required."]
    #[doc = ""]
    #[doc = " @param xCopyPosition Can take the value queueSEND_TO_BACK to place the"]
    #[doc = " item at the back of the queue, or queueSEND_TO_FRONT to place the item"]
    #[doc = " at the front of the queue (for high priority messages)."]
    #[doc = ""]
    #[doc = " @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "struct AMessage"]
    #[doc = "{"]
    #[doc = "char ucMessageID;"]
    #[doc = "char ucData[ 20 ];"]
    #[doc = "} xMessage;"]
    #[doc = ""]
    #[doc = "unsigned long ulVar = 10UL;"]
    #[doc = ""]
    #[doc = "void vATask( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "xQueueHandle xQueue1, xQueue2;"]
    #[doc = "struct AMessage *pxMessage;"]
    #[doc = ""]
    #[doc = "xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );"]
    #[doc = ""]
    #[doc = "xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "if( xQueue1 != 0 )"]
    #[doc = "{"]
    #[doc = "if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( portTickType ) 10, queueSEND_TO_BACK ) != pdPASS )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "if( xQueue2 != 0 )"]
    #[doc = "{"]
    #[doc = "pxMessage = & xMessage;"]
    #[doc = "xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( portTickType ) 0, queueSEND_TO_BACK );"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xQueueSend xQueueSend"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericSend(
        xQueue: xQueueHandle,
        pvItemToQueue: *const c_types::c_void,
        xTicksToWait: portTickType,
        xCopyPosition: c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>"]
    #[doc = "portBASE_TYPE xQueueGenericReceive("]
    #[doc = "xQueueHandle\txQueue,"]
    #[doc = "void\t*pvBuffer,"]
    #[doc = "portTickType\txTicksToWait"]
    #[doc = "portBASE_TYPE\txJustPeek"]
    #[doc = ");</pre>"]
    #[doc = ""]
    #[doc = " It is preferred that the macro xQueueReceive() be used rather than calling"]
    #[doc = " this function directly."]
    #[doc = ""]
    #[doc = " Receive an item from a queue.  The item is received by copy so a buffer of"]
    #[doc = " adequate size must be provided.  The number of bytes copied into the buffer"]
    #[doc = " was defined when the queue was created."]
    #[doc = ""]
    #[doc = " This function must not be used in an interrupt service routine.  See"]
    #[doc = " xQueueReceiveFromISR for an alternative that can."]
    #[doc = ""]
    #[doc = " @param pxQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time the task should block"]
    #[doc = " waiting for an item to receive should the queue be empty at the time"]
    #[doc = " of the call.\t The time is defined in tick periods so the constant"]
    #[doc = " portTICK_RATE_MS should be used to convert to real time if this is required."]
    #[doc = " xQueueGenericReceive() will return immediately if the queue is empty and"]
    #[doc = " xTicksToWait is 0."]
    #[doc = ""]
    #[doc = " @param xJustPeek When set to true, the item received from the queue is not"]
    #[doc = " actually removed from the queue - meaning a subsequent call to"]
    #[doc = " xQueueReceive() will return the same item.  When set to false, the item"]
    #[doc = " being received from the queue is also removed from the queue."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "struct AMessage"]
    #[doc = "{"]
    #[doc = "char ucMessageID;"]
    #[doc = "char ucData[ 20 ];"]
    #[doc = "} xMessage;"]
    #[doc = ""]
    #[doc = "xQueueHandle xQueue;"]
    #[doc = ""]
    #[doc = "void vATask( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "struct AMessage *pxMessage;"]
    #[doc = ""]
    #[doc = "xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = "if( xQueue == 0 )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "pxMessage = & xMessage;"]
    #[doc = "xQueueSend( xQueue, ( void * ) &pxMessage, ( portTickType ) 0 );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "void vADifferentTask( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "struct AMessage *pxRxedMessage;"]
    #[doc = ""]
    #[doc = "if( xQueue != 0 )"]
    #[doc = "{"]
    #[doc = "if( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( portTickType ) 10 ) )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xQueueReceive xQueueReceive"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericReceive(
        xQueue: xQueueHandle,
        pvBuffer: *mut c_types::c_void,
        xTicksToWait: portTickType,
        xJustPeek: c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue );</pre>"]
    #[doc = ""]
    #[doc = " Return the number of messages stored in a queue."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue being queried."]
    #[doc = ""]
    #[doc = " @return The number of messages available in the queue."]
    #[doc = ""]
    #[doc = " \\page uxQueueMessagesWaiting uxQueueMessagesWaiting"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn uxQueueMessagesWaiting(xQueue: xQueueHandle) -> c_types::c_ulong;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>void vQueueDelete( xQueueHandle xQueue );</pre>"]
    #[doc = ""]
    #[doc = " Delete a queue - freeing all the memory allocated for storing of items"]
    #[doc = " placed on the queue."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue to be deleted."]
    #[doc = ""]
    #[doc = " \\page vQueueDelete vQueueDelete"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn vQueueDelete(xQueue: xQueueHandle);
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>"]
    #[doc = "portBASE_TYPE xQueueGenericSendFromISR("]
    #[doc = "xQueueHandle\tpxQueue,"]
    #[doc = "const\tvoid\t*pvItemToQueue,"]
    #[doc = "portBASE_TYPE\t*pxHigherPriorityTaskWoken,"]
    #[doc = "portBASE_TYPE\txCopyPosition"]
    #[doc = ");"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = " It is preferred that the macros xQueueSendFromISR(),"]
    #[doc = " xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place"]
    #[doc = " of calling this function directly."]
    #[doc = ""]
    #[doc = " Post an item on a queue.  It is safe to use this function from within an"]
    #[doc = " interrupt service routine."]
    #[doc = ""]
    #[doc = " Items are queued by copy not reference so it is preferable to only"]
    #[doc = " queue small items, especially when called from an ISR.  In most cases"]
    #[doc = " it would be preferable to store a pointer to the item being queued."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue on which the item is to be posted."]
    #[doc = ""]
    #[doc = " @param pvItemToQueue A pointer to the item that is to be placed on the"]
    #[doc = " queue.  The size of the items the queue will hold was defined when the"]
    #[doc = " queue was created, so this many bytes will be copied from pvItemToQueue"]
    #[doc = " into the queue storage area."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task"]
    #[doc = " to unblock, and the unblocked task has a priority higher than the currently"]
    #[doc = " running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then"]
    #[doc = " a context switch should be requested before the interrupt is exited."]
    #[doc = ""]
    #[doc = " @param xCopyPosition Can take the value queueSEND_TO_BACK to place the"]
    #[doc = " item at the back of the queue, or queueSEND_TO_FRONT to place the item"]
    #[doc = " at the front of the queue (for high priority messages)."]
    #[doc = ""]
    #[doc = " @return pdTRUE if the data was successfully sent to the queue, otherwise"]
    #[doc = " errQUEUE_FULL."]
    #[doc = ""]
    #[doc = " Example usage for buffered IO (where the ISR can obtain more than one value"]
    #[doc = " per call):"]
    #[doc = "<pre>"]
    #[doc = "void vBufferISR( void )"]
    #[doc = "{"]
    #[doc = "char cIn;"]
    #[doc = "portBASE_TYPE xHigherPriorityTaskWokenByPost;"]
    #[doc = ""]
    #[doc = "xHigherPriorityTaskWokenByPost = pdFALSE;"]
    #[doc = ""]
    #[doc = "do"]
    #[doc = "{"]
    #[doc = "cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );"]
    #[doc = ""]
    #[doc = "xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );"]
    #[doc = ""]
    #[doc = "} while( portINPUT_BYTE( BUFFER_COUNT ) );"]
    #[doc = ""]
    #[doc = "if( xHigherPriorityTaskWokenByPost )"]
    #[doc = "{"]
    #[doc = "taskYIELD_YIELD_FROM_ISR();"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = " \\defgroup xQueueSendFromISR xQueueSendFromISR"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericSendFromISR(
        pxQueue: xQueueHandle,
        pvItemToQueue: *const c_types::c_void,
        pxHigherPriorityTaskWoken: *mut c_types::c_long,
        xCopyPosition: c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>"]
    #[doc = "portBASE_TYPE xQueueReceiveFromISR("]
    #[doc = "xQueueHandle\tpxQueue,"]
    #[doc = "void\t*pvBuffer,"]
    #[doc = "portBASE_TYPE\t*pxTaskWoken"]
    #[doc = ");"]
    #[doc = " </pre>"]
    #[doc = ""]
    #[doc = " Receive an item from a queue.  It is safe to use this function from within an"]
    #[doc = " interrupt service routine."]
    #[doc = ""]
    #[doc = " @param pxQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @param pxTaskWoken A task may be blocked waiting for space to become"]
    #[doc = " available on the queue.  If xQueueReceiveFromISR causes such a task to"]
    #[doc = " unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will"]
    #[doc = " remain unchanged."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = ""]
    #[doc = "xQueueHandle xQueue;"]
    #[doc = ""]
    #[doc = "void vAFunction( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "char cValueToPost;"]
    #[doc = "const portTickType xBlockTime = ( portTickType )0xff;"]
    #[doc = ""]
    #[doc = "xQueue = xQueueCreate( 10, sizeof( char ) );"]
    #[doc = "if( xQueue == 0 )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "cValueToPost = 'a';"]
    #[doc = "xQueueSend( xQueue, ( void * ) &cValueToPost, xBlockTime );"]
    #[doc = "cValueToPost = 'b';"]
    #[doc = "xQueueSend( xQueue, ( void * ) &cValueToPost, xBlockTime );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "cValueToPost = 'c';"]
    #[doc = "xQueueSend( xQueue, ( void * ) &cValueToPost, xBlockTime );"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "void vISR_Routine( void )"]
    #[doc = "{"]
    #[doc = "portBASE_TYPE xTaskWokenByReceive = pdFALSE;"]
    #[doc = "char cRxedChar;"]
    #[doc = ""]
    #[doc = "while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )"]
    #[doc = "{"]
    #[doc = "vOutputCharacter( cRxedChar );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "if( cTaskWokenByPost != ( char ) pdFALSE;"]
    #[doc = "{"]
    #[doc = "taskYIELD ();"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xQueueReceiveFromISR xQueueReceiveFromISR"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueReceiveFromISR(
        pxQueue: xQueueHandle,
        pvBuffer: *mut c_types::c_void,
        pxTaskWoken: *mut c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueIsQueueEmptyFromISR(pxQueue: xQueueHandle) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueIsQueueFullFromISR(pxQueue: xQueueHandle) -> c_types::c_long;
}
extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(pxQueue: xQueueHandle) -> c_types::c_ulong;
}
extern "C" {
    pub fn xQueueAltGenericSend(
        pxQueue: xQueueHandle,
        pvItemToQueue: *const c_types::c_void,
        xTicksToWait: portTickType,
        xCopyPosition: c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueAltGenericReceive(
        pxQueue: xQueueHandle,
        pvBuffer: *mut c_types::c_void,
        xTicksToWait: portTickType,
        xJustPeeking: c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueCRSendFromISR(
        pxQueue: xQueueHandle,
        pvItemToQueue: *const c_types::c_void,
        xCoRoutinePreviouslyWoken: c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueCRReceiveFromISR(
        pxQueue: xQueueHandle,
        pvBuffer: *mut c_types::c_void,
        pxTaskWoken: *mut c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueCRSend(
        pxQueue: xQueueHandle,
        pvItemToQueue: *const c_types::c_void,
        xTicksToWait: portTickType,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueCRReceive(
        pxQueue: xQueueHandle,
        pvBuffer: *mut c_types::c_void,
        xTicksToWait: portTickType,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueCreateMutex() -> xQueueHandle;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxCountValue: c_types::c_ulong,
        uxInitialCount: c_types::c_ulong,
    ) -> xQueueHandle;
}
extern "C" {
    pub fn xQueueTakeMutexRecursive(
        xMutex: xQueueHandle,
        xBlockTime: portTickType,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueGiveMutexRecursive(xMutex: xQueueHandle) -> c_types::c_long;
}
extern "C" {
    pub fn uxQueueWaitingReceiveCount_ISR(xQueue: xQueueHandle) -> c_types::c_ulong;
}
extern "C" {
    pub fn uxQueueWaitingSendCount_ISR(xQueue: xQueueHandle) -> c_types::c_ulong;
}
extern "C" {
    pub fn vQueueAddToRegistry(xQueue: xQueueHandle, pcName: *mut c_types::c_schar);
}
pub type xSemaphoreHandle = xQueueHandle;
pub type xCoRoutineHandle = *mut c_types::c_void;
pub type crCOROUTINE_CODE =
    ::core::option::Option<unsafe extern "C" fn(arg1: xCoRoutineHandle, arg2: c_types::c_ulong)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct corCoRoutineControlBlock {
    pub pxCoRoutineFunction: crCOROUTINE_CODE,
    pub xGenericListItem: xListItem,
    pub xEventListItem: xListItem,
    pub uxPriority: c_types::c_ulong,
    pub uxIndex: c_types::c_ulong,
    pub uxState: c_types::c_ushort,
}
#[test]
fn bindgen_test_layout_corCoRoutineControlBlock() {
    assert_eq!(
        ::core::mem::size_of::<corCoRoutineControlBlock>(),
        56usize,
        concat!("Size of: ", stringify!(corCoRoutineControlBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<corCoRoutineControlBlock>(),
        4usize,
        concat!("Alignment of ", stringify!(corCoRoutineControlBlock))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<corCoRoutineControlBlock>())).pxCoRoutineFunction as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(corCoRoutineControlBlock),
            "::",
            stringify!(pxCoRoutineFunction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<corCoRoutineControlBlock>())).xGenericListItem as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(corCoRoutineControlBlock),
            "::",
            stringify!(xGenericListItem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<corCoRoutineControlBlock>())).xEventListItem as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(corCoRoutineControlBlock),
            "::",
            stringify!(xEventListItem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<corCoRoutineControlBlock>())).uxPriority as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(corCoRoutineControlBlock),
            "::",
            stringify!(uxPriority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<corCoRoutineControlBlock>())).uxIndex as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(corCoRoutineControlBlock),
            "::",
            stringify!(uxIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<corCoRoutineControlBlock>())).uxState as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(corCoRoutineControlBlock),
            "::",
            stringify!(uxState)
        )
    );
}
pub type corCRCB = corCoRoutineControlBlock;
extern "C" {
    #[doc = " croutine. h"]
    #[doc = "<pre>"]
    #[doc = "portBASE_TYPE xCoRoutineCreate("]
    #[doc = "crCOROUTINE_CODE pxCoRoutineCode,"]
    #[doc = "unsigned portBASE_TYPE uxPriority,"]
    #[doc = "unsigned portBASE_TYPE uxIndex"]
    #[doc = ");</pre>"]
    #[doc = ""]
    #[doc = " Create a new co-routine and add it to the list of co-routines that are"]
    #[doc = " ready to run."]
    #[doc = ""]
    #[doc = " @param pxCoRoutineCode Pointer to the co-routine function.  Co-routine"]
    #[doc = " functions require special syntax - see the co-routine section of the WEB"]
    #[doc = " documentation for more information."]
    #[doc = ""]
    #[doc = " @param uxPriority The priority with respect to other co-routines at which"]
    #[doc = "  the co-routine will run."]
    #[doc = ""]
    #[doc = " @param uxIndex Used to distinguish between different co-routines that"]
    #[doc = " execute the same function.  See the example below and the co-routine section"]
    #[doc = " of the WEB documentation for further information."]
    #[doc = ""]
    #[doc = " @return pdPASS if the co-routine was successfully created and added to a ready"]
    #[doc = " list, otherwise an error code defined with ProjDefs.h."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vFlashCoRoutine( xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex )"]
    #[doc = "{"]
    #[doc = "static const char cLedToFlash[ 2 ] = { 5, 6 };"]
    #[doc = "static const portTickType uxFlashRates[ 2 ] = { 200, 400 };"]
    #[doc = ""]
    #[doc = "crSTART( xHandle );"]
    #[doc = ""]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = "vParTestToggleLED( cLedToFlash[ uxIndex ] );"]
    #[doc = "crDELAY( xHandle, uxFlashRates[ uxIndex ] );"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "crEND();"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "void vOtherFunction( void )"]
    #[doc = "{"]
    #[doc = "unsigned char ucParameterToPass;"]
    #[doc = "xTaskHandle xHandle;"]
    #[doc = ""]
    #[doc = "for( uxIndex = 0; uxIndex < 2; uxIndex++ )"]
    #[doc = "{"]
    #[doc = "xCoRoutineCreate( vFlashCoRoutine, 0, uxIndex );"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xCoRoutineCreate xCoRoutineCreate"]
    #[doc = " \\ingroup Tasks"]
    pub fn xCoRoutineCreate(
        pxCoRoutineCode: crCOROUTINE_CODE,
        uxPriority: c_types::c_ulong,
        uxIndex: c_types::c_ulong,
    ) -> c_types::c_long;
}
extern "C" {
    #[doc = " croutine. h"]
    #[doc = "<pre>"]
    #[doc = "void vCoRoutineSchedule( void );</pre>"]
    #[doc = ""]
    #[doc = " Run a co-routine."]
    #[doc = ""]
    #[doc = " vCoRoutineSchedule() executes the highest priority co-routine that is able"]
    #[doc = " to run.  The co-routine will execute until it either blocks, yields or is"]
    #[doc = " preempted by a task.  Co-routines execute cooperatively so one"]
    #[doc = " co-routine cannot be preempted by another, but can be preempted by a task."]
    #[doc = ""]
    #[doc = " If an application comprises of both tasks and co-routines then"]
    #[doc = " vCoRoutineSchedule should be called from the idle task (in an idle task"]
    #[doc = " hook)."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vApplicationIdleHook( void )"]
    #[doc = "{"]
    #[doc = "vCoRoutineSchedule();"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "void vApplicationIdleHook( void )"]
    #[doc = "{"]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = "vCoRoutineSchedule();"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vCoRoutineSchedule vCoRoutineSchedule"]
    #[doc = " \\ingroup Tasks"]
    pub fn vCoRoutineSchedule();
}
extern "C" {
    pub fn vCoRoutineAddToDelayedList(xTicksToDelay: portTickType, pxEventList: *mut xList);
}
extern "C" {
    pub fn xCoRoutineRemoveFromEventList(pxEventList: *const xList) -> c_types::c_long;
}


pub mod c_types {
    pub type c_int = i32;
    pub type c_uint = u32;
    pub type c_ulong = u32;
    pub type c_ushort = u16;
    pub type c_short = i16;
    pub type c_schar = i8;
    pub type c_char = i8;
    pub type c_long = i32;
    pub type c_longlong = i64;
    pub enum c_void {}
}
